% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Kalman_filter.R
\name{NFCP_Kalman_filter}
\alias{NFCP_Kalman_filter}
\title{N-Factor Commodity Pricing Kalman Filter}
\usage{
NFCP_Kalman_filter(
  parameter_values,
  parameter_names,
  log_futures,
  dt,
  futures_TTM,
  ME_TTM = NULL,
  verbose = FALSE,
  debugging = FALSE
)
}
\arguments{
\item{parameter_values}{Vector of parameter values of an N-factor model. The \code{NFCP_Kalman_filter} function is designed for
application to \code{optim} type functions, and thus parameter values and
corresponding parameters different inputs within the function.}

\item{parameter_names}{Vector of parameter names. Each element of \code{parameter_names} must correspond to its respective value
element in object \code{parameter_values}.}

\item{log_futures}{Object of class \code{matrix} corresponding to the natural logarithm of observable futures prices.
NA's are allowed within the \code{matrix}. Every column of the matrix must correspond to a particular futures contract,
with each row corresponding to a quoted price on a given date.}

\item{dt}{Constant, discrete time step of observations, in years.}

\item{futures_TTM}{Object of class 'vector' or 'matrix' that specifies the time to maturity of observed futures contracts.
time to maturity can be either constant (ie. class 'vector') or time homogeneous (ie. class 'matrix').
When the time to maturity of observed futures contracts is time homogeneous, the dimensions of
\code{futures_TTM} must be identical to that of \code{log_futures}. Every element of \code{futures_TTM}
corresponds to the time to maturity, in years, of a futures contract at a given observation date.}

\item{ME_TTM}{vector of maturity groupings to consider for observed futures prices. The length of \code{ME_TTM} must be equal to the number of 'ME' parameter values, and the maximum of ME_TTM must be greater than the maximum observed time-to-maturiy of a futures contract. When the number of 'ME' parameter values is equal to one or
the total number of contracts (i.e., columns of \code{log_futures}), this argument is optional and not considered. The measurement error of an observation is highly influenced by its time-to-maturity, see \bold{details}.}

\item{verbose}{\code{logical}. Should additional information be output? see \bold{values}. When \code{verbose = F}, the \code{NFCP_Kalman_filter} function is significantly faster, see \bold{details}}

\item{debugging}{\code{logical}. Should additional filtering information be output? see \bold{values}}
}
\value{
\code{NFCP_Kalman_filter} returns a \code{numeric} object when \code{verbose = F}, which corresponds to the log-likelihood of observations.
When \code{verbose = T}, the \code{NFCP_Kalman_filter} function returns a \code{list} object of length seven with the following objects:

\tabular{ll}{

\code{LL} \tab Log-Likelihood of observations \cr

\code{X.t} \tab \code{vector}. The final observation of the state vector \cr

\code{X} \tab \code{matrix}. All observations of the state vector, after the updating equation has been applied \cr

\code{Y} \tab \code{matrix}. Estimated futures prices at each observation \cr

\code{V} \tab \code{matrix}. Estimation error of each futures contracts at each observation \cr

\code{Filtered Error} \tab \code{matrix}. positive mean error (high bias), negative mean error (low bias), mean error (bias) and root mean squared error (RMSE) of the filtered values to observed futures prices.  \cr

\code{Term Structure Fit} \tab \code{matrix}. The Mean Error (Bias), Mean Absolute Error, Standard Deviation of Error and Root Mean Squared Error (RMSE) of each
observed contract, matching the column names of \code{log_futures}  \cr

\code{Term Structure Volatility Fit} \tab \code{matrix}. The theoretical and empirical volatility of futures returns for each observed contract as returned from the \code{TSfit_volatility} function \cr
}

When \code{debugging = T}, 9 objects are returned in addition to those returned when \code{verbose = T}:

\tabular{ll}{

\code{P_t} \tab \code{array}. The covariance matrix at each observation point, with the third dimension indexing across time \cr

\code{F_t} \tab \code{vector}. The function of the Kalman filter covariance matrix at each observation point, with the third dimension indexing across time \cr

\code{K_t} \tab \code{matrix}. The Kalman Gain at each observation point, with the third dimension indexing across time \cr

\code{d} \tab \code{matrix}.  \mjeqn{d_t}{d[t]} (see \bold{details}) \cr

\code{Z} \tab \code{matrix}.  \mjeqn{Z_t}{z[t]} (see \bold{details}) \cr

\code{G_t} \tab \code{matrix}.  \mjeqn{G_t}{G[t]} (see \bold{details})  \cr

\code{c_t} \tab \code{vector}.  \mjeqn{C_t}{c[t]} (see \bold{details}) \cr

\code{Q_t} \tab \code{matrix}. \mjeqn{Q_t}{Q[t]}  (see \bold{details}) \cr

\code{H} \tab \code{matrix}. \mjeqn{H}{H}  (see \bold{details}) \cr
}
}
\description{
\loadmathjax
Given a set of parameters of the N-factor model, filter term structure data using the Kalman filter.
}
\details{
\code{NFCP_Kalman_filter} applies the Kalman filter algorithm for observable \code{log_futures} prices against the input parameters of an N-factor model
provided through the \code{parameter_values} and \code{parameter_names} input vectors.

The \code{NFCP_Kalman_filter} function is
designed for subsequent input into optimization functions and is called within the N-factor parameter estimation function \code{NFCP_MLE}. The first input to the
\code{NFCP_Kalman_filter} function is a vector of parameters of an
N-factor model, with elements of this vector corresponding to the parameter names within the elements of input vector \code{parameter_names}.
When \code{logical} input \code{verbose = F}, the \code{NFCP_Kalman_filter} function calls the \code{fkf_SP} function of the \code{FKF_SP} package, which itself is a wrapper
of a routine of the Kalman filter written in C utilizing Sequential Processing for maximum computational efficiency (see \code{fkf_SP} for more details). When \code{verbose = T},
the \code{NFCP_Kalman_filter} instead applies a Kalman filter algorithm written in base \code{R} and outputs several other \code{list objects}, including filtered values and
measures for model fit and robustness (see \bold{Returns})

\bold{The N-factor model}
The N-factor model was first presented in the work of Cortazar and Naranjo (2006, equations 1-3). The N-factor framework
describes the spot price process of a commodity as the correlated sum of \mjeqn{N}{N} state variables \mjeqn{x_t}{x[t]}.

When \code{GBM = TRUE}:
\mjdeqn{log(S_{t}) = \sum_{i=1}^N x_{i,t}}{log(S[t]) = sum_{i=1}^n x[i,t]}
When \code{GBM = FALSE}:
\mjdeqn{log(S_{t}) = E + \sum_{i=1}^N x_{i,t}}{log(S[t]) = E + sum_{i=1}^n x[i,t]}

Additional factors within the spot-price process are designed to result in additional flexibility, and possibly fit to the observable term structure, in
the spot price process of a commodity. The fit of different N-factor models, represented by the log-likelihood can be directly compared with statistical
testing possible through a chi-squared test.

Flexibility in the spot price under the N-factor framework allows the first factor to follow a Brownian Motion or Ornstein-Uhlenbeck process to induce a unit root.
In general, an N-factor model where \code{GBM = T}
allows for non-reversible behaviour within the price of a commodity, whilst \code{GBM = F} assumes that there is a long-run equilibrium that
the commodity price will revert to in the long-term.


State variables are thus assumed to follow the following processes:

When \code{GBM = TRUE}:
\mjdeqn{dx_{1,t} = \mu^*dt + \sigma_{1} dw_{1}t}{dx[1,t] = mu^* dt + sigma[1] dw[1]t}

When \code{GBM = FALSE}:
\mjdeqn{dx_{1,t} = - (\lambda_{1} + \kappa_{1}x_{1,t})dt + \sigma_{1} dw_{1}t}{dx[1,t] = - (lambda[1] + kappa[1] x[1,t]) dt + sigma[1] dw[t]t}

And:
\mjdeqn{dx_{i,t} =_{i\neq 1} - (\lambda_{i} + \kappa_{i}x_{i,t})dt + \sigma_{i} dw_{i}t}{dx[i,t] =_(i != 1) - (lambda[i] + kappa[i] x[i,t]dt + sigma[i] dw[i]t)}

where:
\mjdeqn{E(w_{i})E(w_{j}) = \rho_{i,j}}{E(w[i])E(w[j])}

The following constant parameters are defined as:

\code{param} \mjeqn{\mu}{mu}:  long-term growth rate of the Brownian Motion process.

\code{param} \mjeqn{E}{E}: Constant equilibrium level.

\code{param} \mjeqn{\mu^*=\mu-\lambda_1}{mu^* = mu-lambda[1]}: Long-term risk-neutral growth rate

\code{param} \mjeqn{\lambda_{i}}{lambda[i]}: Risk premium of state variable \mjeqn{i}{i}.

\code{param} \mjeqn{\kappa_{i}}{kappa[i]}: Reversion rate of state variable \mjeqn{i}{i}.

\code{param} \mjeqn{\sigma_{i}}{sigma[i]}: Instantaneous volatility of state variable \mjeqn{i}{i}.

\code{param} \mjeqn{\rho_{i,j} \in [-1,1]}{rho[i,j] in [-1,1]}: Instantaneous correlation between state variables \mjeqn{i}{i} and \mjeqn{j}{j}.

\bold{Disturbances - Measurement Error}:

The Kalman filtering algorithm assumes a given measure of measurement error or disturbance in the measurement equation (ie. matrix \mjeqn{H}{H}). Measurement errors can be interpreted as error in the
model's fit to observed prices, or as errors in the reporting of prices (Schwartz and Smith, 2000). These disturbances are typically assumed independent.

\code{var} \mjeqn{ME_i}{ME[i]} measurement error of contract \mjeqn{i}{i}.

where the measurement error of futures contracts \mjeqn{ME_i}{ME[i]} is equal to \code{'ME_'} [i] (i.e. \code{'ME_1'}, \code{'ME_2'}, ...) specified in arguments \code{parameter_values} and \code{parameter_names}.

There are three particular cases on how the measurement error of observations can be treated in the \code{NFCP_Kalman_filter} function:

\bold{Case 1:} Only one ME is specified. The Kalman filter assumes that the measurement error of observations are independent and identical.

\bold{Case 2:} One ME is specified for every observed futures contract. The Kalman filter assumes that the measurement error of observations are independent and unique.

\bold{Case 3:} A series of ME's are specified for a given grouping of maturities of futures contracts. The Kalman filter assumes that the measurement error of observations are independent and unique to their respective time-to-maturity.

Grouping of maturities for case 3 is specified through the \code{ME_TTM} argument. This is a vector that specifies the maximum maturity to consider for each respective ME parameter argument.

in other words, ME_1 is considered for observations with TTM less than ME_TTM[1], ME_2 is considered for observations with TTM less than ME_TTM[2], ..., etc.

The first case is clearly the simplest to estimate, but can be a restrictive assumption. The second case is clearly the most difficult to estimate, but can be an infeasible assumption when considering all available futures contracts that make up the term structure of a commodity.

Case 3 thus serves to ease the restriction of case 1, and allow the user to make the modeling of measurement error as simple or complex as desired for a given set of maturities.

\bold{Kalman Filtering}

The following section describes the Kalman filter equations used to filter the N-factor model.

The Kalman filter iteration is characterised by a transition and measurement equation.
The transition equation develops the vector of state variables between discretised time steps (whilst considering a given level of covariance between state variables over time).
The measurement equation relates the unobservable state vector to a vector of observable measurements (whilst also considering a
given level of measurement error). The typical Kalman filter algorithm is a Gaussian process state space model.

Transition Equation:
\mjdeqn{\hat x_{t|t-1} = c_t + G_t \hat x_{t-1} + Q_t \eta_t }{hat(x)[t|t-1] = c[t] + G[t] * hat(x)[t-1]}
Measurement Equation:
\mjdeqn{\hat y_t = d_t + Z_t \hat x_{t|t-1} + H_t \epsilon_t}{hat(y)[t] = d[t] + Z[t] * hat(x)[t|t-1]}

\mjdeqn{t = 1, \cdots, n }{t = 1, ..., n}

Where \mjeqn{\eta_t}{eta[t]} and \mjeqn{\epsilon_t}{epsilon[t]} are IID \mjeqn{N(0,I(m))}{N(0,I(m))} and iid \mjeqn{N(0,I(d))}{N(0,I(d))} respectively.

The state vector follows a normal distribution, \mjeqn{x_1 \sim N(a_1, P_1)}{x[1] ~ N(a[1], P[1])}, with \mjeqn{a_1}{a[1]} and \mjeqn{P_1}{P[1]} as the mean vector and variance matrix of
the initial state vector \mjeqn{x_1}{x[1]}, respectively.

The Kalman filter can be used for parameter estimation through the maximization of the Log-Likelihood value. See \code{NFCP_MLE}.

\bold{Filtering the N-factor model}

let \mjeqn{m}{m} represent the number of observations at time \mjeqn{t}{t}

let \mjeqn{n}{n} represent the number of factors in the N-factor model

observable futures prices: \mjeqn{y_t = [ln(F(t,T_1)), ln(F(t,T_2)), \cdots, ln(F(t,T_m))]'}{y[t] = [ln(F(t,T[1])), ln(F(t,T[2])), ..., ln(F(t,T[m]))]'}

State vector: \mjeqn{x_t=[x_1t,x_2t,\cdots,x_nt ]'}{x[t] = [x[1t], x[2t], ..., x[nt]]'}

Measurement error: \mjeqn{diag(H) = [ME_{1}^2, ME_{2}^2, \cdots, ME_{n}^2]}{diag(H) = [ME[1]^2, ME[2]^2, ..., ME[n]^2]}

When the number of specified ME terms is one, \mjeqn{s_1 = s_2 = \cdots = s_n = }{s[1] = s[2] = ... = s[n] = } \mjeqn{ME_1^2}{ME[1]^2}

\code{var} \mjeqn{Z}{Z} is an \mjeqn{m \times n}{m X n} matrix, where each element \mjeqn{[i,j]}{[i,j]} is equal to:

\mjdeqn{Z_{i,j} = e^{-\kappa_i T_j}}{Z[i,j] = e^(-kappa[i] * T[j])}

\code{var} \mjeqn{d_t}{d[t]} is an \mjeqn{m \times 1}{m X 1} vector:

\mjdeqn{d_t=[A(T_1), A(T_2), \cdots, A(T_m)]'}{d[t]=[A(T[1]), A(T[2]), ..., A(T[m])]'}

Under the assumption that Factor 1 follows a Brownian Motion, \eqn{A(T)} is given by:
\mjdeqn{A(T) = \mu^*T-\sum_{i=1}^N - \frac{1-e^{-\kappa_i T}\lambda_i}{\kappa_i}+\frac{1}{2}(\sigma_1^2T +
\sum_{i.j\neq 1} \sigma_i \sigma_j \rho_{i,j} \frac{1-e^{-(\kappa_i+\kappa_j)T}}{\kappa_i+\kappa_j})}{A(T) = mu^* * T - sum_{i=1}^N (1-e^(-kappa[i] T) lambda[i])/(kappa[i]) + 1/2 (sigma[1]^2 * T)
+ sum_{i.j != 1} sigma[i] sigma[j] rho[i,j] (1 - e^(-(kappa[i] + kappa[j]) * T)) / (kappa[i] + kappa[j])}

\code{var} \mjeqn{v_t}{v[t]} is a \mjeqn{n \times 1}{n X 1} vector of serially uncorrelated Guassian disturbances with
\mjeqn{E(V_t) = 0}{E(V[t]) = 0}  and \mjeqn{cov(v_t)=R^2}{cov(v[t])=R^2}

Where:

\mjeqn{diag(G_t) = [e^{-\kappa_1 \tau}, e^{-\kappa_2 \tau}, \cdots, e^{-\kappa_n \tau}]}{diag(G[t]) = [e^{-kappa[1] tau}, e^{-kappa[2] tau}, ..., e^{-kappa[n] tau}}


Where \mjeqn{ \tau =T-t}{tau = T - t}

\code{var} \mjeqn{w_t}{w[t]} is an \mjeqn{n \times 1}{n X 1} vector of serially uncorrelated Guassian disturbances where:
\mjdeqn{E(w_t) = 0}{E(w[t]) = 0} and \mjeqn{cov(w_t) = Q_t}{cov(w[t]) = Q[t]}

\code{var} \mjeqn{c_t=[\mu \Delta t,0,\cdots,0]'}{c[t] = [mu * Delta t, 0, ..., 0]'} is an \mjeqn{N \times 1}{N X 1} vector of the intercept of the transition equation.

\code{var} \mjeqn{Q_t}{Q[t]} is equal to the covariance function, given by:

\mjdeqn{Cov_{1,1}(x_{1,t},x_{1,t}) = \sigma_1^2t}{Cov[1,1](x[1,t],x[1,t]) = sigma[1]^2 * t}
\mjdeqn{Cov_{i,j}(x_{i,t},x_{j,t}) = \sigma_i\sigma_j\rho_{i,j}\frac{1-e^{-(\kappa_i+\kappa_j)t}}{\kappa_i+\kappa_j}}{Cov[i,j](x[i,t],x[j,t]) = sigma[i] sigma[j] rho[i,j] (1-e^{-(kappa[i]+kappa[j]) * t) / (kappa[i] + kappa[j])}}
(see also \code{cov_func})

\bold{Penalising poorly specified models}

The Kalman filter returns non-real log-likelihood scores when the function of the covariance matrix becomes singular or its determinant becomes negative.
This occurs when a poorly specified parameter set is input. Non-real log-likelihood scores can break optimization algorithms. To circumvent this, the \code{NFCP_Kalman_filter}
returns a heavily penalized log-likelihood score whilst also returning a warning. Penalized log-likelihood scores are calculated by:

\code{stats::runif(1, -1.5e6, -1e6)}

\bold{Diffuse Kalman filtering}

If the initial values of the state vector are not supplied within the \code{parameter_names} and \code{parameter_values} vectors (ie. \code{Initial.State = F} within the
\code{NFCP_parameters} function), a 'diffuse' assumption is used within the Kalman filtering algorithm. Factors that follow an Ornstein-Uhlenbeck are assumed to equal zero.
The initial value of factors that follow a Brownian motion are assumed equal to the first element of \code{log_futures}. This is an
assumption that the initial estimate of the spot price is equal to the closest to maturity observed futures price.

The initial covariance of the state vector for the Kalman filtering algorithm assumed to be equal to matrix \mjeqn{Q}{Q}

Initial states of factors that follow an Ornstein-Uhlenbeck have a transient effect on future
observations, however the initial value of a random walk variable persists across observations and therefore influencing model fit more (see Schwartz and Smith (2000) for more details).
}
\examples{


##Example 1 - complete, stitched data.
##Replicating the Schwartz and Smith (2000)
##Two-Factor commodity pricing model applied to crude oil:

SS_stitched_filtered <- NFCP_Kalman_filter(
parameter_values = SS_oil$two_factor,
parameter_names = names(SS_oil$two_factor),
log_futures = log(SS_oil$stitched_futures),
futures_TTM = SS_oil$stitched_TTM,
## maturity groupings need not be considered here:
ME_TTM = NULL,
dt = SS_oil$dt,
verbose = FALSE)


##Example 2 - incomplete, contract data.
##Replicating the Schwartz and Smith (2000)
##Two-Factor commodity pricing model applied to all available
##crude oil contracts:

SS_2F <- SS_oil$two_factor
##omit stitched contract white noise
SS_2F <- SS_2F[!grepl("ME",
             names(SS_2F))]

# Evaluate two different measurement errors
SS_2F[c("ME_1", "ME_2")] <- c(0.01, 0.04)

## Seperate measurement error into two different maturity groupings
SS_ME_TTM <- c(1,3)
## ME_1 is applied for observed contracts with less than one year
## maturity, whilst ME_2 considers contracts with maturity greater
## than one year, and less than three years

#Kalman filter
SS_contract_filtered <- NFCP_Kalman_filter(
parameter_values = SS_2F,
parameter_names = names(SS_2F),
## All available contracts are considered
log_futures = log(SS_oil$contracts),
## Respective 'futures_TTM' of these contracts are input:
futures_TTM = SS_oil$contract_maturities,
ME_TTM = SS_ME_TTM,
dt = SS_oil$dt,
verbose = FALSE)
}
\references{
Anderson, B. D. O. and J. B. Moore, (1979). \emph{Optimal filtering} Englewood Cliffs: Prentice-Hall.

Fahrmeir, L. and G. tutz,(1994) \emph{Multivariate Statistical Modelling Based on Generalized Linear Models.} Berlin: Springer.

Schwartz, E. S., and J. E. Smith, (2000). Short-Term Variations and Long-Term Dynamics in Commodity Prices. \emph{Manage. Sci.}, 46, 893-911.

Cortazar, G., and L. Naranjo, (2006). An N-factor Gaussian model of oil futures prices. \emph{Journal of Futures Markets: Futures, Options, and Other Derivative Products}, 26(3), 243-268.

Durbin, J., and S. J. Koopman, (2012). \emph{Time series analysis by state space methods.} Oxford university press.
}
